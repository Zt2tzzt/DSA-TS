# 双向链表-堆结构

## 一、双向链表的实现

双向链表中添加、删除方法的实现和单向链表有较大的区别，所以我们可以对其方法进行重新实现：

- `append` 方法：在尾部追加元素（重写父类的方法）；
- `insert` 方法：根据索引插入元素（重写父类的方法）；
- `removeAt` 方法：根据索引删除元素（重写父类的方法）；
- `prepend` 方法：在头部添加元素（新方法）；
- `postTraverse` 方法：从尾部遍历所有节点（新方法）；

准备工作：

重写 `LinkedList` 类中的，`head`，`tail` 属性，类型改为 `DoublyNode` 类型。

> 多态的体现：
>
> 不能将一个父类的对象, 赋值给一个子类的类型；
>
> 可以将一个子类的对象, 赋值给一个父类的类型(多态)

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript
import LinkedList from './01-单向链表重构'
import { DoublyNode } from './LinkedNode'

export class DoublyLinkedList<T> extends LinkedList<T> {
  protected head: DoublyNode<T> | null = null
  protected tail: DoublyNode<T> | null = null
}
```

## 二、append 方法

重写 `LinkedList` 类的 `append` 方法；

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript
import LinkedList from './01-单向链表重构'
import { DoublyNode } from './LinkedNode'

export class DoublyLinkedList<T> extends LinkedList<T> {
  protected head: DoublyNode<T> | null = null
  protected tail: DoublyNode<T> | null = null

  append(value: T): void {
    const newNode = new DoublyNode(value)

    if (!this.head) { // 如果链表中没有存放元素
      this.head = newNode
      this.tail = newNode
    } else {
      this.tail!.next = newNode
      newNode.prev = this.tail
      this.tail = newNode
    }

    this.length++
  }
}

// 测试
const dlinkedList = new DoublyLinkedList<string>()
dlinkedList.append('aaa')
dlinkedList.append('bbb')
dlinkedList.append('ccc')
dlinkedList.append('ddd')

dlinkedList.append('abc')
dlinkedList.append('cba')

dlinkedList.traverse()

```

## 三、prepend 方法

在 `DoublyLinkedList` 类中，新增 `prepend` 方法，用于在链表头部插入元素。

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript
import LinkedList from './01-单向链表重构'
import { DoublyNode } from './LinkedNode'

export class DoublyLinkedList<T> extends LinkedList<T> {
  protected head: DoublyNode<T> | null = null
  protected tail: DoublyNode<T> | null = null
  
  // ...

  prepend(value: T): void {
    const newNode = new DoublyNode(value)
    
    if (!this.head) { // 如果链表中没有存放元素
      this.head = newNode
      this.tail = newNode
    } else {
      newNode.next = this.head
      this.head.prev = newNode
      this.head = newNode
    }

    this.length++
  }
}

const dlinkedList = new DoublyLinkedList<string>()
dlinkedList.append('aaa')
dlinkedList.append('bbb')
dlinkedList.append('ccc')
dlinkedList.append('ddd')

dlinkedList.prepend('abc')
dlinkedList.prepend('cba')

dlinkedList.traverse()
```

## 四、postTraverse 方法

在 `DoublyLinkedList` 类中，新增 `postTraverse` 方法，用于反向遍历。

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript
import LinkedList from './01-单向链表重构'
import { DoublyNode } from './LinkedNode'

export class DoublyLinkedList<T> extends LinkedList<T> {
  protected head: DoublyNode<T> | null = null
  protected tail: DoublyNode<T> | null = null

	// ...
  
  postTraverse() {
    const values: T[] = []
    let current = this.tail
    while (current) {
      values.push(current.value)
      current = current.prev
    }

    console.log(values.join('->'))
  }
}

const dlinkedList = new DoublyLinkedList<string>()
dlinkedList.append('aaa')
dlinkedList.append('bbb')
dlinkedList.append('ccc')
dlinkedList.append('ddd')

dlinkedList.prepend('abc')
dlinkedList.prepend('cba')

dlinkedList.traverse()
dlinkedList.postTraverse()
```

## 五、insert 方法

重新实现，根据索引插入元素。

将父类中的 `getNode` 方法，改为使用 `protected` 修饰。

demo-project\08-高阶链表结构\01-单向链表重构.ts

```typescript
class LinkedList<T> implements ILinkedList<T> {
  //...
  
  protected getNode(position: number): Node<T> | null {
    let index = 0
    let current = this.head
    while (index++ < position && current) {
      current = current.next
    }

    return current
  }
  
  //...
}
```

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript
import LinkedList from './01-单向链表重构'
import { DoublyNode } from './LinkedNode'

export class DoublyLinkedList<T> extends LinkedList<T> {
  protected head: DoublyNode<T> | null = null
  protected tail: DoublyNode<T> | null = null

	// ...
  
  insert(position: number, value: T): boolean {
    if (position < 0 || position > this.length) return false

    if (position === 0) {
      this.prepend(value)
    } else if (position === this.length) {
      this.append(value)
    } else {
      const newNode = new DoublyNode(value)
      const current = this.getNode(position) as DoublyNode<T>

      current.prev!.next = newNode
      newNode.next = current
      newNode.prev = current.prev
      current.prev = newNode // 该操作，要放在最后。

      this.length++
    }

    return true
  }
}

const dlinkedList = new DoublyLinkedList<string>()
dlinkedList.append('aaa')
dlinkedList.append('bbb')
dlinkedList.append('ccc')
dlinkedList.append('ddd')

dlinkedList.prepend('abc')
dlinkedList.prepend('cba')

dlinkedList.traverse()
dlinkedList.postTraverse()

dlinkedList.insert(0, "why")
dlinkedList.insert(7, "kobe")
dlinkedList.insert(3, "james")

dlinkedList.traverse()
dlinkedList.postTraverse()
```





removeAt 方法

考虑删除的是头节点，为节点。

- 考虑链表中，仅有一个元素的情况。



其它方法，直接使用继承过来的。

进行测试。

---

堆结构是什么？

---

为什么需要堆结构

---

认识堆结构

> 费曼讲什么是火：
>
> 1. 认识大自然的巧妙，
> 2. 思考在讲解时的逻辑组织方式。

---

堆结构的设计



堆结构的封装

封装一个私有工具方法 swag，用于两个节点的交换。

