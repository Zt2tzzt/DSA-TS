# 双向链表-堆结构

## 一、双向链表的实现

双向链表中添加、删除方法的实现和单向链表有较大的区别，所以我们可以对其方法进行重新实现：

- `append` 方法：在尾部追加元素（重写父类的方法）；
- `insert` 方法：根据索引插入元素（重写父类的方法）；
- `removeAt` 方法：根据索引删除元素（重写父类的方法）；
- `prepend` 方法：在头部添加元素（新方法）；
- `postTraverse` 方法：从尾部遍历所有节点（新方法）；

准备工作：

重写 `LinkedList` 类中的，`head`，`tail` 属性，类型改为 `DoublyNode` 类型。

> 多态的体现：
>
> 不能将一个父类的对象, 赋值给一个子类的类型；
>
> 可以将一个子类的对象, 赋值给一个父类的类型(多态)

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript
import LinkedList from './01-单向链表重构'
import { DoublyNode } from './LinkedNode'

export class DoublyLinkedList<T> extends LinkedList<T> {
  protected head: DoublyNode<T> | null = null
  protected tail: DoublyNode<T> | null = null
}
```

## 二、append 方法

重写 `LinkedList` 类的 `append` 方法；

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript
import LinkedList from './01-单向链表重构'
import { DoublyNode } from './LinkedNode'

export class DoublyLinkedList<T> extends LinkedList<T> {
  protected head: DoublyNode<T> | null = null
  protected tail: DoublyNode<T> | null = null

  append(value: T): void {
    const newNode = new DoublyNode(value)

    if (!this.head) { // 如果链表中没有存放元素
      this.head = newNode
      this.tail = newNode
    } else {
      this.tail!.next = newNode
      newNode.prev = this.tail
      this.tail = newNode
    }

    this.length++
  }
}

// 测试
const dlinkedList = new DoublyLinkedList<string>()
dlinkedList.append('aaa')
dlinkedList.append('bbb')
dlinkedList.append('ccc')
dlinkedList.append('ddd')

dlinkedList.append('abc')
dlinkedList.append('cba')

dlinkedList.traverse()

```

## 三、prepend 方法

在 `DoublyLinkedList` 类中，新增 `prepend` 方法，用于在链表头部插入元素。

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript
import LinkedList from './01-单向链表重构'
import { DoublyNode } from './LinkedNode'

export class DoublyLinkedList<T> extends LinkedList<T> {
  protected head: DoublyNode<T> | null = null
  protected tail: DoublyNode<T> | null = null
  
  // ...

  prepend(value: T): void {
    const newNode = new DoublyNode(value)
    
    if (!this.head) { // 如果链表中没有存放元素
      this.head = newNode
      this.tail = newNode
    } else {
      newNode.next = this.head
      this.head.prev = newNode
      this.head = newNode
    }

    this.length++
  }
}

const dlinkedList = new DoublyLinkedList<string>()
dlinkedList.append('aaa')
dlinkedList.append('bbb')
dlinkedList.append('ccc')
dlinkedList.append('ddd')

dlinkedList.prepend('abc')
dlinkedList.prepend('cba')

dlinkedList.traverse()
```

## 四、postTraverse 方法

在 `DoublyLinkedList` 类中，新增 `postTraverse` 方法，用于反向遍历。

demo-project\08-高阶链表结构\03-双向链表doublyLinkedList.ts

```typescript

```





insert 方法

重新实现，根据索引插入元素。

将父类中的 getNode 方法，改为 protected 修饰。

current.prev = newNode 操作，放在最后。



removeAt 方法

考虑删除的是头节点，为节点。

- 考虑链表中，仅有一个元素的情况。



其它方法，直接使用继承过来的。

进行测试。

---

堆结构是什么？

---

为什么需要堆结构

---

认识堆结构

> 费曼讲什么是火：
>
> 1. 认识大自然的巧妙，
> 2. 思考在讲解时的逻辑组织方式。

---

堆结构的设计



堆结构的封装

封装一个私有工具方法，用于两个节点的交换。

