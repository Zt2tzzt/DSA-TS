# 高级链表结构 & 单向循环链表 & 双向链表

## 一、二叉树重构

思考：以前封装的二叉搜索树中，能不能放一个对象模型（比如：Product），而不是 number 类型的值？

- 答案是可以的。

默认情况下，两个对象之间不能比较。

要在类中实现 `valueOf` 方法，才能让类的两个实例之间，进行比较。

> `valueOf` 只能用于 <, >, 这样的运算符比较，不能用于 === 全等运算符的比较。

demo-project\00_测试代码\01-对象之间的比较方式.ts

```typescript
class Person {

  constructor(public name: string, public age: number) {}

  valueOf() {
    return this.age;
  }
}

const p1 = new Person("John", 30);
const p2 = new Person("Jane", 26);
console.log(p1 < p2); // false
console.log(p1 > p2); // true

const p3 = new Person("zzt", 26)
console.log(p3 === p2) // false
console.log(p3 == p2) // false
```

在二叉树 BSTree 类中，转入 Product 对象实例。

```typescript
/**
 * @description: 此类用于：二叉搜索树的封装
 * @Author: ZeT1an
 */
class BSTree<T> {
  // ...
}

class Product {
  constructor(public name: string, public price: number) {}

  valueOf() {
    return this.price
  }
}

const p1 = new Product('IPhone', 100)
const p2 = new Product('Huawei', 120)
const p3 = new Product('Xiaomi', 80)
const p4 = new Product('oppo', 90)
const p5 = new Product('vivo', 70)

// 测试
const bst = new BSTree<Product>()
bst.insert(p1)
bst.insert(p2)
bst.insert(p3)
bst.insert(p4)
bst.insert(p5)

bst.print()
```

我们之前封装的 TreeNode 类，正好有 value，left，right 属性；

所以可以直接使用 `hy-algokit` 工具包的 `btPrint` 方法打印二叉树。

那么，如果 TreeNode 中的属性是 data，leftNode, rightNode呢？又或者，并且想要打印的是 Product 对象实例的信息呢（比如：name + data）？

这时，就需要 TreeNode 类，实现 `hy-algokit` 工具包中的 `PrintableNode` 接口，它要求实现  value，left，right 这三个属性。

重构二叉树 `TreeNode` 类，实现 `PrintableNode` 接口，。

demo-project\06-二叉搜索树\15-二叉搜索树Tree（存放Product对象）.ts

```typescript
import { PrintableNode, btPrint } from 'hy-algokit'

class Node<T> {
  constructor(public data: T) {}
}

class TreeNode<T> extends Node<T> implements PrintableNode {
  left: TreeNode<T> | null = null
  right: TreeNode<T> | null = null
  // 当前节点的父节点
  parent: TreeNode<T> | null = null

  get isLeft(): boolean {
    return !!(this.parent && this.parent.left === this)
  }
  get isRight(): boolean {
    return !!(this.parent && this.parent.right === this)
  }

  get value() {
    const data = (this.data) as Product
    return `${data.name} - ${data.price}`
  }
}

/**
 * @description: 此类用于：二叉搜索树的封装
 * @Author: ZeT1an
 */
class BSTree<T> {
  // ...
}

class Product {
  constructor(public name: string, public price: number) {}

  valueOf() {
    return this.price
  }
}

const p1 = new Product('IPhone', 100)
const p2 = new Product('Huawei', 120)
const p3 = new Product('Xiaomi', 80)
const p4 = new Product('oppo', 90)
const p5 = new Product('vivo', 70)

// 测试
const bst = new BSTree<Product>()
bst.insert(p1)
bst.insert(p2)
bst.insert(p3)
bst.insert(p4)
bst.insert(p5)

bst.print()
/*
                          IPhone - 100
                ┌───────────────┴───────────────┐
           Xiaomi - 80                    Huawei - 120
        ┌───────┴───────┐
    vivo - 70       oppo - 90
*/
```

另一种设计思路：在 `BSTree` 类的 `constructor` 中，传入一个 `comparator` 函数，用于比较两个节点的大小。

demo-project\06-二叉搜索树\15-二叉搜索树Tree（存放Product对象）.ts

```typescript
/**
 * @description: 此类用于：二叉搜索树的封装
 * @Author: ZeT1an
 */
class BSTree<T> {
  private root: TreeNode<T> | null = null
  private comparator: (a: T, b: T) => number

  constructor(comparator: (a: T, b: T) => number) {
    this.comparator = comparator
  }

  //...

  private searchNode(value: T): TreeNode<T> | null {

    //...

      // 2.继续向下找
      parent = current
      if (this.comparator(current.data, value)) {
        current = current.left
      } else {
        current = current.right
      }

      // 如果 current 有值，那么 current 保存自己的父节点
      if (current) current.parent = parent

    // ...
  }

  //...
}

// 测试
const bst = new BSTree<Product>((c1, c2) => {
  return c1.price - c2.price
})
//...
```

不建议这么用，因为 JS 中已经有非常好用的 `valueOf` 方法，用于类的实例进行比较。

## 二、循环链表是什么？

前面我们已经从零去封装了一个链表结构，其实在此基础上，还可以封装更加灵活的链表结构：即“循环链表”和“双向链表”。

**循环链表（Circular LinkedList）**是一种特殊的链表数据结构：

- 在普通链表的基础上，最后一个节点的下一个节点，不再是 null，而是指向链表的第一个节点。
- 这样形成了一个环，使得链表能够被无限遍历。
- 遍历一个单向循环链表，可从任意一个节点出发，不断地遍历下一个节点，直到回到起点。

![循环链表](NodeAssets/循环链表.jpg)

单向循环链表，有两种实现方式：

- 方式一：从零去实现一个新的链表，包括其中所有的属性和方法；
- 方式二：继承自之前封装的 `LinkedList`，只实现差异化的部分（下方采用）；

## 三、重构单向链表类 linkedList

将封装好的 LinkedList 类中的 head，length 用 protected 修饰。

新增 tail 属性，表示尾部节点。

- 重构 append 方法。
- 重构 insert 方法。考虑在尾部插入节点的情况。
- 重构 removeAt 方法。考虑链表中，仅有一个节点的情况；和删除的是最后一个节点的情况。

新增一个方法，判断 node 节点是否为最后一个节点。

重构 traverse 方法，避免死循环，打印时形成环。

- 可以用“模板模式”（设计模式）将逻辑进行抽取，交给字类完成，但没必要，反而麻烦。

重构 indexOf 方法，避免死循环。

---

封装 CircularLinkedList 类。

重新实现 append 方法。

重新实现 insert 方法。

- 考虑在头部，尾部插入节点的情况。

重写 remoreAt 方法

- 考虑在头部，尾部删除节点的情况。

---

双向链表的结构



封装 DoublyNode 类，继承自 Node，重写 next 属性
