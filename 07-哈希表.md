# 哈希表

## 一、哈希函数

讲了很久的哈希表理论知识，我们会发现，在整个过程中，一个非常重要的东西：哈希函数呢？

好的哈希函数，应该尽可能让计算的过程，变得简单，提高计算的效率。

- 哈希表的主要优点，是它的速度，所以在速度上不能体现优势，那么就达不到设计的目的了。
- 提高速度的一个办法，就是让哈希函数中，尽量少的有乘法和除法。因为它们的性能是比较低的。

设计好的哈希函数应该具备哪些优点呢？

- 快速的计算
  - 哈希表的优势就在于效率，所以快速获取到对应的 hashCode 非常重要。

- 均匀的分布
  - 哈希表中，无论是链地址法，还是开放地址法，当多个元素映射到同一个位置的时候，都会影响效率。
  - 所以，优秀的哈希函数，应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布。

## 二、霍纳法则

在前面介绍中，计算哈希值的时候，使用的方式：

- `cats = 3 * 27³ + 1 * 27² + 20 * 27 + 17 = 60337`

这种方式，是直观的计算结果，那么这种计算方式，会进行几次乘法几次加法呢？

- 当然，我们可能不止 4 项（4 个单词），可能有更多项。
- 抽象一下，这个表达式，其实是一个多项式：
- a(n)x^n^ + a(n-1)x^(n-1)^ + … + a(1)x + a(0)

现在问题就变成了，多项式有多少次乘法和加法：

- 乘法次数：n＋(n－1)＋…＋1＝n(n+1)/2，复杂度为 `O(n^2^)`。
- 加法次数：n 次，复杂度为 `O(n)`。
- 总体来说，复杂度为 `O(N²)`。

解决这类求值问题的多项式优化：要用到**霍纳法则**。在中国，霍纳法则 也被称为**秦九韶算法**。

通过如下变换，我们可以得到一种快得多的算法，即

- Pn(x) = anx^n^ + a(n－1)x^(n-1)^ + … + a1x + a0
- = ((…(((anx + an － 1)x + an－2)x + an － 3)…)x + a1)x + a0，
- 这种求值的方式我们称为霍纳法则。

变换后，我们需要多少次乘法，多少次加法呢？

- 乘法次数：N 次。
- 加法次数：N 次。

如果使用大 O 表示时间复杂度的话，我们直接从 `O(N²)` 降到了 `O(N)`。

## 四、均匀分布

均匀分布：

- 在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：即链地址法，或者开放地址法。
- 但是无论哪种方案，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。
- 因此，我们需要在使用常量的地方，尽量使用**质数**。
- 哪些地方我们会使用到常量呢？

**质数**的使用：

- 常用于**哈希表的长度**，N 次幂的底数(之前案例中使用的是 27)。

为什么使用质数，会让哈希表分布更加均匀呢？

- 质数和其他数相乘的结果，相比于非质数，更容易产生唯一性的结果，减少哈希冲突。
- Java 中的 N 次幂的底数，选择的是 31，是经过长期观察分布结果得出的；

### 1.N 次幂底数

这里采用质数的原因是，为了产生的数据不按照某种规律递增。

- 比如我们这里有一组数据是按照 4 进行递增的：0 4 8 12 16，将其映射到长度为 8 的哈希表中。
- 它们的位置是多少呢？0 - 4 - 0 - 4，依次类推。
- 如果我们哈希表本身不是质数，而我们递增的数量可以使用质数，比如 5，那么就是 0 5 10 15 20；
- 它们的位置是多少呢？0 - 5 - 2 - 7 - 4，依次类推。也可以尽量让数据均匀的分布。
- 我们之前使用的是 27，这次可以使用一个接近的数，比如 31/37/41 等等。一个比较常用的数是 31 或 37。

总之，质数是一个非常神奇的数字。

这里建议两处都使用质数：

- 哈希表中数组的长度。
- N次幂的底数。

## 五、Java 中的 HashMap（了解）

Java 中的哈希表，采用的是链地址法。

HashMap 的初始长度是 16，每次自动扩展，长度必须是 2 的次幂。

- 这是为了服务于从 Key 映射到 index 的算法。`60000000 % 100 = 数字`。下标值

HashMap 中为了提高效率，采用了位运算的方式。

- HashMap 中 index 的计算公式：`index = HashCode（Key） & （Length - 1）`
- 比如计算"book"的 hashcode，结果为十进制的 `3029737`，二进制的 `1011100011101011101001`
- 假定 HashMap 长度是默认的 `16`，计算 `Length-1` 的结果为十进制的 `15`，二进制的 `1111`。
- 把以上两个结果做与运算，`101110001110101110001 & 1111 = 1001`，十进制是 9，所以 `index = 9`

但是，JavaScript 中，进行较大数据的位运算时，可能会出问题，所以下面的代码实现中，还是使用了**取余**。

- 另外，为了方便代码之后向开放地址法中迁移，容量还是选择使用**质数**。

## 六、哈希函数的实现

---

哈希表的实现

插入/修改数据 put 方法。



获取数据 get 方法。



删除数据 delete 方法。

---

哈希表扩容思想



扩容函数的实现

- 取出数组中的元素，
- 将数组赋值为空。
- 对取出的元素，进行再哈希化。



缩容的实现。

一般在装填因子 < 0.25 的时候。且数组有一个最小长度的情况下（比如 7）