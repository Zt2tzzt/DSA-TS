# 平衡树

## 一、AVLTree 的基本封装

### 1.insert 方法的调整和再平衡

每插入一个节点，就往上找它的父节点，直到找到不平衡的父节点，对它进行旋转。

调整 `BSTree` 类中的 `insert` 方法，怎么拿到插入的节点？有两种方案：

方案一：在 `BSTree` 类的 `insert` 方法中，返回 `newNode`，不推荐。

方案二：在 `BSTree` 类中，实现 `checkBalance` 方法，但其中什么也没做，在 `AVLTree` 类中，重写 `checkBalance` 方法（模板模式）。

demo-project\11-平衡二叉树\BSTree.ts

```typescript
/**
 * @description: 此类用于：二叉搜索树的封装
 * @Author: ZeT1an
 */
class BSTree<T> {
  // ...

  protected checkBalance(node: TreeNode<T>) {}

  /**
   * @description: 此函方法于：二叉搜索树的插入操作。
   * @Author: ZeT1an
   * @param {T} value 插入的值
   * @return {*}
   */
  insert(value: T) {
    // 1.根据传入的 value，创建 Node 节点。
    const newNode = this.createNode(value)

    // 2.判断当前是否已经有了根节点
    if (!this.root) {
      this.root = newNode
    } else {
      this.insertNode(this.root, newNode)
    }

    this.checkBalance(newNode)
  }

  // ...
}
```

demo-project\11-平衡二叉树\04-封装AVLTree（插入的调整）.ts

```typescript
class AVLTree<T> extends BSTree<T> {
  // ...

  // 查找不平衡的节点，并对该节点进行再平衡
  protected checkBalance(node: AVLTreeNode<T>) {
    let current = node.parent

    while (current) {
      if (!current.isBalance) {
        this.rebalance(current)
      }
      current = current.parent
    }
  }
}
```

### 2.remove 方法的调整和再平衡

每删除一个节点，就往上找它的父节点，每找到不平衡的父节点，对它进行旋转。直到找到根节点。

思考： checkBalance传入谁？

- 很明显应该是删除的节点；
- 但是如果有两个子节点的情况，我们需要找的是前期和后继，最终是将前驱和后继位置的节点删除掉的；
- 寻找的应该是从AVL树中被移除位置的节点；

调整 `BSTree` 中，`remove` 方法，处理删除节点父节点的引用：（ `replaceNode` 的 `parent` 引用）有三种情况：

- 情况一：删除的节点是叶节点，没有子节点。
  - 传入 current 节点即可，并且根据它的 parent 去寻找失衡节点；
- 情况二：删除的节点，仅有一个子节点。
  - 传入 current 节点即可，并且根据它的 parent 去寻找失衡节点；
- 情况三：删除的节点，有两个子节点（要拿到前驱 / 后继）。
  - 以前的做法：找到后继节点，替换删除的节点；
  - 现在的做法：找后继节点的值（value），替换删除节点的值（value），这样做更简单。

这里的关键点是两个：

- 关键点一：必须要找到检测位置的节点；
- 关键点二：检测位置的节点必须有父节点；

寻找 delNode 节点：

- 情况一，和情况二：delNode 节点有正确的父节点，但是后面的替换节点会失去正确的父节点；
- 情况三：如果需要找后继节点，那么父节点的操作会比较复杂；我们可以利用我之前提到的第二种方案，来减少一些父节点的设置操作；

rebalance 优化

- 添加的情况，不需要进一步向上查找父节点，再平衡
- 删除的情况，需要进一步向上查找父节点，直到找到根节点，再平衡

目前我们 rebalance 的操作是哪些节点会执行呢？

- 插入节点的所有父节点（一直向上查找父节点）；
- 删除节点的所有父节点（一直向上查找父节点）；

但是 是否需要每次插入、删除都需要将所有的父节点都rebalance操作呢？

- 这个取决于在插入一个节点后后，是否改变了祖父节点的高度；
- 这个取决于在删除一个节点后后，是否改变了祖父节点的高度；

我们得出结论：

- 插入节点，再平衡 rebalance 后不需要继续后续节点的再平衡 rebalance ；
- 删除节点，再平衡 rebalance 后需要继续后续节点的再平衡 rebalance；

在 rebalance  方法中，传入一个参数 isAdd。

demo-project\11-平衡二叉树\BSTree.ts

```typescript
/**
 * @description: 此类用于：二叉搜索树的封装
 * @Author: ZeT1an
 */
class BSTree<T> {
  protected checkBalance(node: TreeNode<T>, isAdd = true) {}

    /**
   * @description: 此方法用于：二叉搜索树中，节点的删除。
   * @Author: ZeT1an
   * @param {T} value
   * @return {*}
   */
  remove(value: T): boolean {
    // 1.查找 value 所在的节点
    const current = this.searchNode(value)
    if (!current) return false

    let delNode: TreeNode<T> | null = current

    let replaceNode: TreeNode<T> | null = null
    // 2.获取到三个东西，当前节点 / 父节点 / 当前节点是左子节点，还是右子节点
    // console.log('当前节点：', current.value, '父节点：', current.parent?.value)
    // 删除的是叶子节点
    if (current.left === null && current.right === null) {
      replaceNode = null
    }

    // 3.只有一个子节点
    else if (current.right === null) {
      // 只有左子节点
      replaceNode = current.left
    } else if (current.left === null) {
      // 只有右子节点
      replaceNode = current.right
    }

    // 4.有两个子节点
    else {
      const successor = this.getSuccessor(current)

      current.value = successor.value
      delNode = successor
      this.checkBalance(delNode)

      return true
    }

    if (current === this.root) {
      this.root = replaceNode
    } else if (current.isLeft) {
      current.parent!.left = replaceNode
    } else {
      current.parent!.right = replaceNode
    }

    // 判断 replaceNode
    if (replaceNode && current.parent) {
      replaceNode.parent = current.parent
    }

    // 删除完成后，检测树是否平衡（传入的节点是那个真正从二叉树中被移除的节点）
    this.checkBalance(delNode, false)

    return true
  }
}
```

## 二、红黑树是什么？

从 2-3-4 树，B 树演化而来。

首先，红黑树是数据结构中很难的一个知识点，难到什么程度呢?

- 基本你跟别人聊数据结构的时候, 他不会和你聊红黑树, 因为它是数据结构中一个难点中的难点.
- 数据结构的学习本来就比较难了, 红黑树是又将难度上升一个档次的知识点.

面试的时候经常出现这个场景:

- 面试官: 你知道红黑树吗?
- 面试者: 知道啊。
- 面试官: 知道原理吗?
- 面试者: 不知道啊。
- 面试官: 那你让‘不’过来面试我们公司吧，你先回去等通知吧。

哪些面试会出现红黑树呢?

- 在面试时基本不会让手写红黑树（即使是面试Google、Apple这样的公司，也很少会出现）。
- 通常是这样问题的（比如腾讯的一次面试题）：为什么已经有平衡二叉树（比如AVL树）了，还需要红黑树呢？

![红黑树表情包](https://pic1.zhimg.com/80/v2-2ec996460c145095cc917d6dbe771318_720w.webp)

**红黑树（Red–black tree）**是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构。

1972 年由鲁道夫·贝尔发明，被称为“对称二叉B树”，它现代的名字源于 Leo.J.Guibas 和罗伯特·塞奇威克于 1978 年写的一篇论文。

红黑树, 除了符合二叉搜索树的基本规则外, 还添加了以下 5 个特性（重要）：

- 节点是红色或黑色。
- 根节点是黑色。
- 每个叶子节点，都是黑色的空节点（NIL 节点）。
  - 这是因为在红黑树中，黑色节点的数量，表示从根节点到该节点的黑色节点数量。
- 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上，不能有两个连续的红色节点)
  - 该性质保证了红色节点的颜色不会影响树的平衡，同时保证了红色节点的出现不会导致连续的红色节点。
  - 红色节点的存在，用于尽量少去调整这棵树。
- 从任一节点，到其每个叶子的所有路径，都包含相同数目的黑色节点（最重要）。
  - 第五条性质是**最重要**的性质，保证了红黑树的平衡性。

![红黑树](https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg)

## 三、红黑树的相对平衡

前面的性质约束，确保了红黑树的关键特性:

- 从根到叶子的最长可能路径, 不会超过最短可能路径的两倍长。
- 结果就是这个树基本是平衡的。
- 虽然没有做到绝对的平衡，但是可以保证在最坏的情况下, 依然是高效的。

为什么可以做到最长路径不超过最短路径的两倍？

- 性质五决定了最短路径，和最长路径必须有相同的黑色节点；
- 路径最短的情况：全部是黑色节点n；
- 路径最长的情况：首尾解释黑色节点n，中间全部是红色节点n – 1（一红一黑交替节点。）；
  - 性质二：根节点是黑节点；（黑色节点的数量也是 n）
  - 性质三：叶子节点都是黑节点；
  - 性质四：两个红色节点不能相连
- 最短路径为 n – 1（边的数量）；
- 最长路径为 (n + n – 1) - 1 = 2n – 2；
- 所以最长路径 一定不超过 最短路径的2倍；

## 四、红黑树的代码实现（了解）

手写一个 TypeScript 红黑树的详细步骤：

- 定义红黑树的节点：定义一个带有键、值、颜色、左子节点、右子节点和父节点的类；
- 实现左旋操作：将一个节点向左旋转，保持红黑树的性质；
- 实现右旋操作：将一个节点向右旋转，保持红黑树的性质；
- 实现插入操作：在红黑树中插入一个新的节点，并保持红黑树的性质；
- 实现删除操作：从红黑树中删除一个节点，并保持红黑树的性质；
- 实现修复红黑树性质：在插入或删除操作后，通过旋转和变色来修复红黑树的性质；
- 其他方法较为简单，可以自行实现；

具体代码参考我的 Markdown 笔记。

## 五、红黑树性能分析

牺牲了一点点搜索性能，来提高插入、删除的性能。

事实上，红黑树的性能在搜索上是不如AVL树的，为什么呢？

我们来看一下右边的红黑树：

- 首先，它符合是一颗红黑树吗？符合。
- 这个时候我们插入 节点30，会被插入到哪里呢？ ✓ 27的右边，并且节点30是红色节点时，依然符合红黑树的性质。
Nil
- 也就是对于红黑树来说，它不需要进行任何操作；

那么AVL树会怎么样呢？

- 如果是AVL树必然要对17、25、27节点进行右旋转；
- 事实上右旋转是一系列的操作；

但是红黑树的高度比AVL树要高：

- 所以如果同样是搜索30，那么红黑树需要搜索4次，AVL树搜索3次；
- 所以红黑树相当于牺牲了一点点的搜索性能，来提高了插入和删除的性能；

## 六、AVL 和 红黑树的选择

 AVL树和红黑树的性能对比：

- AVL树是一种平衡度更高的二叉搜索树，所以在搜索效率上会更高；
- 但是AVL树为了维护这种平衡性，在插入和删除操作时，通常会进行更多的旋转操作，所以效率相对红黑树较低；
- 红黑树在平衡度上相较于AVL树没有那么严格，所以搜索效率上会低一些；
- 但是红黑树在插入和删除操作时，通常需要更少的旋转操作，所以效率相对AVL树较高；
- 它们的搜索、添加、删除时间复杂度都是O(logn)，但是细节上会有一些差异；

 开发中如何进行选择呢？

- 选择AVL树还是红黑树，取决于具体的应用需求。
- 如果需要保证每个节点的高度尽可能地平衡，可以选择AVL树。
- 如果需要保证删除操作的效率，可以选择红黑树。

 在早期的时候，很多场景会选择AVL树，目前选择红黑树的越来越多（AVL树依然是一种重要的平衡树）。

- 比如操作系统内核中的内存管理；
- 比如Java的TreeMap、TreeSet底层的源码；
