# 排序算法

## 一、快速排序

### 1.代码优化

三数取中

demo-project\12-排序算法\06-快速排序（quickSort）-三数取中.ts

```typescript
import { swap, testSort, measureSort } from 'hy-algokit';

function quickSort(arr: number[]): number[] {

  partition(0, arr.length - 1)

  function partition(start: number, end: number) {
    if (start >= end) return arr

    // 三数取中
    const mid = Math.floor((start + end) / 2)
    if (mid > start && mid < end) {
      if (arr[start] > arr[end]) swap(arr, start, end)
      if (arr[mid] > arr[end]) swap(arr, mid, end)
      if (arr[start] > arr[mid]) swap(arr, start, end)
      swap(arr ,mid, end)
    }

    const pivot = arr[end] // 将原数组最后一个元素，作为基准元素 pivot

    let i = start, j = end - 1 // 双指针

    // 交换后的结果，左边都是比 pivot 小的数字，右边都是比 pivot 大的数字
    while (i <= j) {
      while (arr[i] < pivot) i++
      while (arr[j] > pivot) j--

      if (i <= j) {
        swap(arr, i, j)
        i++
        j--
      }
    }

    // 将 pibot 放在正确位置，以它为基准，再切割成两个数组，进行快速排序
    swap(arr, i, end)
    partition(start, j)
    partition(i + 1, end)
  }

  return arr
}

// 测试
testSort(quickSort)
measureSort(quickSort)
```

## 二、堆排序

### 1.堆排序的介绍

堆排序（Heap Sort）的核心思想是：使用二叉堆来维护一个有序序列。

- 二叉堆是一种**完全二叉树**，其中每个节点，都满足父节点比子节点大（或小）的条件。
- 在堆排序中，我们使用最大堆来进行排序，也就是保证每个节点都比它的子节点大。

在堆排序中，我们首先构建一个最大堆。

- 然后，将堆的根节点（即最大值）与堆的最后一个元素交换，这样最大值就被放在了正确的位置上。
- 接着，将堆的大小减小一，并将剩余的元素重新构建成一个最大堆。
- 不断重复这个过程，直到堆的大小为1。 这样，我们就得到了一个有序的序列。

堆排序和选择排序有一定的关系，因为它们都利用了“选择”这个基本操作。

- 选择排序的基本思想，是在待排序的序列中选出最小（或最大）的元素，然后将其放置到序列的起始位置。
- 堆排序也是一种选择排序算法，它使用最大堆来维护一个有序序列，然后不断选择出最大的值。

选择的时间复杂度为 `O(n)`，构建堆的时间复杂度是 `O(log n)`，堆排序的时间复杂度为 `O(nlogn)`。

### 2.堆排序的思路分析

堆排序可以分成两大步骤：“构建最大堆”和“排序”：

构建最大堆：

1. 自下而上的下滤。

排序：

1. 将堆的根节点（也就是最大值）与堆的最后一个元素交换，这样最大值就被放在了正确的位置上。
2. 将堆的大小减一，并将剩余的元素，重新构建成一个最大堆。
3. 重复进行步骤 1 和步骤 2，直到堆的大小为 1，这样我们就得到了一个有序的序列。

### 3.堆排序的图解

![堆排序1](NodeAssets/堆排序1.jpg)

### 4.堆排序代码实现

使用原地建堆，在数组末尾交换最大值。

demo-project\12-排序算法\07-堆排序（heapSort）.ts

```typescript
import { swap, testSort, measureSort } from 'hy-algokit';

export default function heapSort(arr: number[]): number[] {
  const n = arr.length

  // 对 arr 原地建堆，自下而上的下滤
  const lastNonLeafNode = Math.floor((n - 1) / 2 - 1)
  for (let i = lastNonLeafNode; i >= 0; i--) {
    heapfy_down(arr, n, i)
  }

  // 对最大堆，进行排序操作
  for (let i = n - 1; i > 0; i--) {
    swap(arr, 0, i)
    heapfy_down(arr, i, 0)
  }

  return arr
}

function heapfy_down(arr: number[], n: number, index: number) {
  while (2 * index + 1 < n) {
    // 1.定义索引位置
    const leftChildIndex = 2 * index + 1
    const rightChildIndex = leftChildIndex + 1

    // 2.找到左右子节点较小的值
    let largeIndex = leftChildIndex
    if (rightChildIndex < n && arr[rightChildIndex] > arr[leftChildIndex]) {
      largeIndex = rightChildIndex
    }

    // 3.较小的之和 index 位置进行比较
    if (arr[index] >= arr[largeIndex]) break

    // 4.变换位置
    swap(arr, index, largeIndex)
    index = largeIndex
  }
}

// 测试
testSort(heapSort)
measureSort(heapSort)
```

### 5.堆排序复杂度分析

堆排序的时间复杂度分析较为复杂，因为它既涉及到堆的建立过程，也涉及到排序过程。

步骤一：堆的建立过程

- 堆的建立过程包括 n / 2 次堆的向下调整操作，因此它的时间复杂度为 O(n)。

步骤二：排序过程

- 排序过程需要执行 n 次堆的删除最大值操作，每次操作都需要将堆的最后一个元素与堆顶元素交换，然后向下 调整堆。
- 每次向下调整操作的时间复杂度为 O(log n)，因此整个排序过程的时间复杂度为 O(n log n)。

综合起来，堆排序的时间复杂度为 O(n log n)。

需要注意的是，堆排序的空间复杂度为 O(1)，因为它只使用了常数个辅助变量来存储堆的信息。









总结

---

父节点索引的推导。

正确的公式：floor(i - 2 -1)

---

希尔排序

介绍

插入排序的回顾

实现思路

增量怎么取？

代码实现

时间复杂度分析

总结

---

测试多种排序算法

使用 hy-algokit 中的 compareSort 方法。

大多数情况下：快速排序 > 堆排序 > 归并排序 > 希尔排序

---

基数排序，桶排序，计数排序空间复杂度比较高