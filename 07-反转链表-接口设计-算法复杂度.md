面试题：反转链表。

使用递归和非递归的两种方式。

非递归：

考虑的情况：

1.head 本身为 null 的情况。

2.head 只有一个节点。

3.至少有两个节点。

使用栈结构来解决该问题，避免栈中末尾节点的循环引用的问题。

- 多创建了一个数组，空间复杂度较高。不推荐的方案。



使用非递归的方法解决：

考虑的情况：

1.head 本身为 null 的情况。

2.head 只有一个节点。

将上述两种情况的处理，合并为一行代码。

3.至少有两个节点。

处理步骤：

1.先让 current 指向下一个节点。

- 目的：保留下一个几点的引用，使它可达，不会被销毁。

2.改变 head 指向的节点为 newHead

- 对于第一个节点来说，指向 newHead，就是指向 null

3.让 newHead 指向 head 节点。

- 目的是下一次遍历时，第二步操作，可以让下一个节点，指向第一个节点。

4.让 head 移向下一个节点，指向 current

经过上面的步骤，可以反转一个节点。

> tsc 默认不能有隐式的 any 类型，要再 tsconfig.json 中配置。



使用递归的方式进行反转。

先找到最后一个节点，再往前面的节点进行操作。



核心是指针的变化

---

为封装的链表，定义一个接口。

IList

- IStack
  - ArrayStack 类
  - LinkedStack 类（自行实现）
- IQueue
  - ArrayQueue 类
- ILinkedList
  - LinkedList 类
    - DoubleLinkedList 类（自行实现）

---

算法复杂度

回顾什么是算法。



算法复杂度是什么？

一般考虑“最坏”、“平均”时间复杂度。

假设在 10000 个元素中，进行查找。

顺序查找

- 最坏：n
- 平均：n / 2

二分查找：

- 最坏：log(10000, 2)
- 平均：log(10000, 2) / 2



程序案例

> JavaScript 中提供了 performance，用于测试函数调用的时间。



安装 hy-algokit 库，用于测试函数的调用时间