# 算法复杂度 & 哈希表

## 一、大 O 表示法

**大O表示法（Big O notation）**英文置译为“大 O 符号”（维基百科翻译），中文通常翻译为大 O 表示法（标记法）。

- 这个记号，是在德国数论学家爱德蒙·兰道的著作中推广的，因此它有时又称为**兰道符号（Landau symbols）**。
- 代表“order of ...”（……阶）的大 O，最初是一个大写希腊字母“Ο”（omicron），现今用的是大写拉丁字母“O”。

大 O 符号，在分析算法效率的时候非常有用。

- 比如，解决一个规模为 n 的问题，所花费的时间（或者所需步骤的数目）可以表示为：
  - 当 n 增大时，n² 项开始占据主导地位，其他各项可以被忽略；
- 说明：当 n=500
  - 4n² 项是 2n 项的 1000 倍，因此在大多数场合下，省略后者，对表达式的值的影响，是可以忽略不计的。
  - 进一步看，如果我们与任一其他级的表达式比较，n² 的系数也是无关紧要的。

我们说该算法，具有 n² 阶（平方阶）的时间复杂度，表示为 O(n²)。

:egg: 案例理解：

顺序查找举例：

```typescript
function sequentSearch(array: number[], num: number) {
  const length = array.length
  for (let i = 0; i < length; i++) {
    if (array[i] === num) {
      return i
    }
  }
  return -1
}
```

上面代码，指令执行的次数，大致是是 5n + 2。推导成大 O 表示法为 O(n)？

### 1.常见对数阶

常用的函数阶

| 符号                   | 名称                                              |
| ---------------------- | ------------------------------------------------- |
| O(1)                   | 常数阶                                            |
| O(log n)               | 对数阶                                            |
| O(n)                   | 线性，次线性阶                                    |
| O(nlog n)              | 线性对数/对数线性/拟线性/超线性阶段，如快速排序。 |
| O(n²)                  | 平方阶                                            |
| O(n²)， Integer(c > 1) | 多项式/代数阶，效率低                             |
| O(c^n^)                | 指数/几何阶，效率低                               |

表达式推导大 O 表示法

| 案例                 | 时间复杂度 | 术语       |
| -------------------- | ---------- | ---------- |
| 123456789            | 0(1)       | 常数阶     |
| 2n + 1               | O(n)       | 线性阶     |
| 6n^2^ + 3n + 2       | O(n^2^)    | 平方阶     |
| 6n^3^ + 3n + 2       | O(n^3^)    | 立方阶     |
| 3log(2^n^) + 3n + 2  | O(log n)   | 对数阶     |
| 3nlog(2^n^) + 3n + 2 | O(nlog n)  | 线性对数阶 |
| 2^n^                 | O(2^n^)    | 指数阶     |

函数阶的效率：

![函数阶的效率](NodeAssets/函数阶效率.jpg)

> 如果要在无序的数组中查找，有两种方式：
>
> - 先排序，再二分查找。
> - 如不想打乱顺序，就线性查找。
>
> tree 结构，可到达 O(log n)
>
> Hash 表，可到达 O(1)

## 二、空间复杂度

空间复杂度，指的是程序运行过程中，所需要的额外存储空间。

空间复杂度也可以用大 O 表示法来表示；

空间复杂度的计算方法，与时间复杂度类似，通常需要分析程序中，需要额外分配的内存空间：

- 如数组、变量、对象、递归调用（栈）等。

举个栗子🌰：

- 对于一个递归算法来说，每次调用，都会在内存中分配新的**栈帧**，占用了额外的空间，因此，该算法的空间复杂度是 O(n)，其中 n 是递归深度。
- 对于一个迭代算法来说，在每次迭代中，不需要分配额外的空间，因此，其空间复杂度为 O(1)。

当空间复杂度很大时，可能会导致内存不足，程序崩溃。

在平时进行算法优化时，我们通常会进行如下的考虑：

- 使用尽量少的空间（优化空间复杂度）；
- 使用尽量少的时间（优化时间复杂度）；
- 特定情况下：使用**空间换时间**或使用**时间换空间**；
  - 比如：动态规划，其中可以使用递归，但不推荐。

> 一般对比算法的复杂度，还是以“时间复杂度”为主。

## 三、数组和链表的复杂度对比

大 O 表示法，对比数组和链表的时间复杂度

| Data Structure | Access | Search                              | Insertion | Deletion |
| -------------- | ------ | ----------------------------------- | --------- | -------- |
| Array          | O(1)   | O(n)（有序数组，可优化成 O(log n)） | O(n)      | O(n)     |
| Linked list    | O(n)   | O(n)                                | O(1)      | O(1)     |

数组是一种连续的存储结构，通过下标，可以直接访问数组中的任意元素。

- 时间复杂度：对于数组，随机访问时间复杂度为 O(1)，插入和删除操作时间复杂度为 O(n)。
- 空间复杂度：数组需要连续的存储空间，空间复杂度为 O(n)。

链表是一种链式存储结构，通过指针链接起来的节点组成，访问链表中元素需要从头结点开始遍历。

- 时间复杂度：对于链表，随机访问时间复杂度为 O(n)，插入和删除操作时间复杂度为 O(1)。
- 空间复杂度：链表需要为每个节点分配存储空间，空间复杂度为 O(n)。

在实际开发中，选择使用数组还是链表 需要根据具体应用场景来决定。

- 如果数据量不大，且需要频繁随机访问元素，使用数组会更好。
- 如果数据量大，或者需要频繁插入和删除元素，使用链表会更好。

## 四、哈希表的优势/劣势

几乎所有的编程语言，都有直接或者间接地，应用这 Hash 表这种数据结构。

哈希表通常是基于数组进行实现的，但是相对于数组，它有很多的优势：

- 可提供非常快速的插入-删除-查找操作；
- 无论多少数据，插入和删除值，都接近常量阶的时间：即 O(1) 的时间复杂度。只需要几个机器指令即可完成；
- 哈希表的速度比 Tree 树还要快，基本可以瞬间查找到想要的元素；
- 哈希表相对于树来说，编码要容易很多；

哈希表相对于数组的一些不足：

- 哈希表中的数据，是**没有顺序**的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素（没有特殊处理情况下）。
- 通常情况下，哈希表中的 key 是不允许重复的，不能放置相同的 key，用于保存不同的元素。

## 五、哈希表是什么？

哈希表不像数组、链表，树一样，可以直观地画出空间结构。

事实上，它的结构就是数组，但是它的特点在于，对数组下标值的一种变换，

这种变换，通常指的是，通过哈希函数可以获取到 HashCode。

![hash表](NodeAssets/hash表.jpg)

哈希表中可以使用数组和链表。

## 六、两个案例

下面两个案例，需要你挑选某种数据结构，而你会发现最好的选择就是哈希表。

- 案例一：公司使用一种数据结构来保存所有员工；
- 案例二：使用一种数据结构，存储单词信息；
  - 比如有 50000 个单词。找到单词后，每个单词有自己的翻译 & 读音 & 应用...；

### 1.公司员工存储

案例介绍：

- 一家公司有 1000 个员工，现在我们需要将这些员工的信息，使用某种数据结构保存起来。
- 应该采用什么数据结构呢？

方案一：数组

- 该方案按照顺序，将所有的员工，依次存入一个长度为 1000 的数组中。
- 每个员工的信息，都保存在数组的某个位置上。
- 然而，要查看某个具体员工的信息，会不太好找。
- 因为，数组最大的优势是通过下标值去获取信息。
- 所以，为了可以通过数组快速定位到某个员工，最好给员工信息中添加一个员工编号(工号)， 而编号对应的就是员工的数组下标值。

- 当查找某个员工的信息时，通过员工编号，可以快速定位到员工的信息位置。

方案二：链表

- 链表对应插入和删除数据有一定的优势。
- 但是对于获取员工的信息，每次都必须从头遍历到尾，这种方式显然不是特别适合我们这里。

最终方案：

- 这样看，最终方案似乎就是数组了。但是数组还是有缺点。
- 如果不知道员工的编号，要根据员工的姓名查找，数组结构就没有优势了？

- 有没有一种办法，让 zzt 的名字，和它的员工编号，产生直接的关系？
- 也就是通过 zzt 这个名字，就能获取到它的索引值，而再通过索引值，就能获取到 zzt 的信息？
- 这样的方案已经存在了，就是使用**哈希函数**，让某个 key 的信息，和索引值对应起来。

### 2.50000 个单词的存储

案例介绍：

- 使用一种数据结构，存储单词信息，比如有 50000 个单词。
- 找到单词后，每个单词有自己的翻译 & 读音 & 应用...

方案一：数组

- 这个案例，能更加明显地感受到数组的缺陷。
- 比如一个单词 Iridescent，我想找到这个单词的翻译/读音/应用。怎么可以从数组中查到这个单词的位置呢？
- 线性查找？50000 次比较？如果你使用数组来实现这个功能，效率会非常非常低，而且你一定没有学习过数据结构。

方案二：链表？

- 更不需要考虑了？

方案三：有没有一种方案，可以将单词转成数组的下标值呢？

- 如果单词转成数组的下标，那么以后我们要查找某个单词的信息，直接按照下标值一步即可访问到想要的元素。

## 七、字符串转下标值

似乎所有的案例，都指向了一个目标：将字符串转成下标值。

怎样才能将一个字符串转成数组的下标值呢？

- 单词/字符串转下标值，其实就是字母/文字转数字

现在我们需要设计一种方案，可以将单词转成适当的下标值：

- 其实，计算机中有很多的编码方案，就是用数字代替单词的字符。即**字符编码**。
- 比如 ASCII 编码：a 是 97，b 是 98，依次类推 122 代表 z
- 我们也可以设计一个自己的编码系统，比如 a 是 1，b 是 2，c 是 3，依次类推，z是 26。
- 当然我们可以加上空格用 0 代替，就是 27 个字符（不考虑大写问题）。
- 但是，有了编码系统后，一个单词如何转成数字呢？

将查询的关键词，与数组下标（索引）联系起来。有以下两种方案：

### 1.方案一：数字相加

一种转换单词的简单方案，就是把单词每个字符的编码求和。

- 例如：单词 cats 转成数字：3+1+20+19=43，那么，43 就作为 cats 单词的下标存在数组中。

这种方案，有一个很明显的问题，就是很多单词，最终的下标，可能都是 43。

- 比如 was/tin/give/tend/moan/tick...。
- 我们知道，数组中一个下标值位置，只能存储一个数据。
- 如果存入后来的数据，必然会造成数据的覆盖。
- 一个下标存储这么多单词显然是不合理的。
- 虽然后面的方案也会出现，但是要尽量避免。

### 2.方案二：幂的连乘

数字相加的方案就有些过于普通了。

现在，我们想通过一种算法，让 cats 转成数字后，不那么普通。

有一种方案，就是使用幂的连乘，什么是幂的连乘呢？

- 其实我们平时使用的大于 10 的数字，可以用一种幂的连乘来表示它的唯一性：
  - 比如：7654 = 7 * 10³ + 6 * 10² + 5 * 10 + 4
- 单词也可以使用这种方案来表示：
  - 比如 cats = 3 * 27³ + 1 * 27² + 20 * 27 + 17 = 60337
- 这样得到的数字可以基本保证它的唯一性，不会和别的单词重复。

问题：如果一个单词是 zzzzzzzzzz（一般英文单词不会超过 10 个字符）。那么，得到的数字将超过 7000000000000。

- 数组可以表示这么大的下标值吗？
- 而且就算能创建这么大的数组，事实上有很多是无效的单词。
- 创建这么大的数组是没有意义的。

## 八、下标的压缩

现在需要一种压缩方法，把幂的连乘方案，系统中得到的巨大整数范围，压缩到可接受的数组范围中。

对于英文词典，多大的数组才合适呢？

- 如果只有 50000 个单词，可能会定义一个长度为 50000 的数组。
- 但是实际情况中，往往需要更大的空间来存储这些单词。比如两倍的大小：100000。
- 因为不能保证单词会映射到每一个位置。

如何压缩呢？

- 把 0 到超过 7000000000000 的范围， 压缩为从 0 到 100000。
- 有一种简单的方法，就是使用取余操作符，它的作用是得到一个数被另外一个数整除后的余数。

取余操作的实现：

- 为了看到这个方法如何工作，我们先来看一个小点的数字范围，压缩到一个小点的空间中。
- 假设把从0~199的数字，比如使用largeNumber代表， 压缩为从0到9的数字，比如使用smallRange代表。
- 下标值的结果：index = largeNumber % smallRange;
- 当一个数被10整除时，余数一定在0~9之间;
- 比如13%10=3，157%10=7。
- 当然，这中间还是会有重复，不过重复的数量明显变小了。 因为我们的数组是100000，而只有50000个单词。
- 就好比，你在0~199中间选取5个数字，放在这个长度为 10的数组中，也会重复，但是重复的概率非常小。(后面我们会讲到真的发生重复了应该怎么解决)


---

哈希表中的一些概念

---

冲突是什么？

> 冲突不可避免，我们只能解决冲突。

---

链地址法

---

开放地址法。



线性探测



二次探测



再哈希法

---

哈希化的效率。



线性探测



二次探测



再哈希法



链地址法