# 面试题

## 一、栈结构

### 1.用两个栈实现队列结构

[Leetcode 原题](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/)

题面：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead`，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -`1` )

demo-project\14-大厂面试题Leetcode\06-用两个栈实现队列结构.ts

```typescript
class CQueue {
  private stack1: number[] = []
  private stack2: number[] = []
  constructor() {}

  appendTail(value: number): void {
    this.stack1.push(value)
  }

  deleteHead(value: number): number {
    // 1.判断 stack2 中是否有数据
    if (this.stack2.length > 0) {
      return this.stack2.pop()!
    }
    
    // 2.判断 stack1 中是否有数据
    else if (this.stack1.length > 0) {
      // 从 stack1 中，取出所有的数据，放到 stack2 中。
      while (this.stack1.length > 0) {
        const item = this.stack1.pop()!
        this.stack2.push(item)
      }

      return this.stack2.pop()!
    }
    
    else {
      return -1
    }
  }
}
```

## 二、队列

### 1.滑动窗口最大值

经典的双端队列应用场景，也可以用动态规划解决。

题面：给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口，从数组的最左侧，移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```txt
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```txt
输入：nums = [1], k = 1
输出：[1]
```

demo-project\14-大厂面试题Leetcode\07-滑动窗口最大值.ts

```typescript
function maxSlidingWindow(nums: number[], k: number): number[] {
  const n = nums.length

  // 创建双端队列，琼中存放索引
  const dequeue: number[] = []
  const res: number[] = []

  // 遍历每一个元素
  for (let i = 0; i < n; i++) {
    // 移除窗口左侧超出范围的元素索引
    if (dequeue.length > 0 && dequeue[0] < i - k + 1) {
      dequeue.shift()
    }
    
    // 如果，双端队列不为空，并且队列尾部的索引对应的值，小于遍历的值
    // 则将元素，放入到双端队列的尾部
    while (dequeue.length && nums[i] > nums[dequeue[dequeue.length - 1]]) {
      dequeue.pop()
    }
    dequeue.push(i)


    // 获取到头部的值，作为最大值
    if (i >= k - 1) {
      res.push(nums[dequeue[0]])
    }
  }

  return res
}

// 测试
console.log(maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3))
```

## 三、链表

### 1.删除链表的倒数第 N 个节点

[Leetcode 原题](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

题目：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

思路：可以使用双指针，来解决这个问题。

- 首先让快指针先移动 n 步，然后让慢指针和快指针一起移动， 直到快指针到达链表末尾。
- 此时慢指针所指的节点，就是要删除的节点的前一个节点，可以将其指向下下个节点，从而删除倒数第 n 个节点。
- 其中 dummy 节点，是为了方便处理边界情况而添加的。

demo-project\14-大厂面试题Leetcode\08-删除链表倒数第n个节点.ts

```typescript
//  Definition for singly-linked list.
class ListNode {
  val: number
  next: ListNode | null
  constructor(val?: number, next?: ListNode | null) {
    this.val = val === undefined ? 0 : val
    this.next = next === undefined ? null : next
  }
}

function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
  if (!head) return null

  // 1.创建虚拟节点
  const dummy = new ListNode(0)
  dummy.next = head

  // 2.创建双指针（快慢指针）
  let slow = dummy
  let fast = dummy

  // 3.先让快指针，移动到 n + 1 个节点
  for (let i = 0; i<= n; i++) {
    fast = fast.next!
  }

  // 2.同时移动 fast 和 slow，直到 fast 到达链表末尾
  while (fast) {
    fast = fast.next!
    slow = slow.next!
  }

  slow.next = slow.next ? slow.next.next : null

  return dummy.next
}

```

### 2.两两交换链表中的节点

[Leetcode 原题](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

题目：给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

实现思路：

- 首先添加一个 dummy 节点；
- 创建一个 p 节点，默认指向虚拟节点（这里因为有虚拟节点，所以可以直接调用 next）；
- 使用一个指针 p 依次指向每组相邻的节点，然后交换这两个节点的位置，直到遍历完整个链表。

demo-project\14-大厂面试题Leetcode\09-两两交换链表中的节点.ts

```typescript
// Definition for singly-linked list.
export class ListNode {
  val: number
  next: ListNode | null
  constructor(val?: number, next?: ListNode | null) {
    this.val = val === undefined ? 0 : val
    this.next = next === undefined ? null : next
  }
}

function swapPairs(head: ListNode | null): ListNode | null {
  // 1.创建虚拟节点
  const dummy = new ListNode(0, head)

  // 2.创建 current 节点，指向虚拟节点
  let curr = dummy
  while (curr.next && curr.next.next) {
    // 将接下来的两个节点取出
    const node1 = curr.next
    const node2 = curr.next.next

    // 交换 node1 和 node2 的位置
    curr.next = node2
    node1.next = node2.next
    node2.next = node1

    // 开始下一次的交换
    curr = node1
  }

  return dummy.next
}
```

## 四、二叉树

### 1.二叉树的前序、中序、后序、层序遍历

前序遍历：

demo-project\14-大厂面试题Leetcode\10-二叉树的前序遍历.ts

```typescript
// Definition for a binary tree node.
class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val
    this.left = left === undefined ? null : left
    this.right = right === undefined ? null : right
  }
}

function preorderTraversal(root: TreeNode | null): number[] {
  const res: number[] = []
  recursionTraversal(root, res)
  return res
}

function recursionTraversal(node: TreeNode | null, res: number[]) {
  if (node) {
    res.push(node.val)
    recursionTraversal(node.left, res)
    recursionTraversal(node.right, res)
  }
}
```

中序遍历：

demo-project\14-大厂面试题Leetcode\11-二叉树中序遍历.ts

```typescript
//  Definition for a binary tree node.
class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val
    this.left = left === undefined ? null : left
    this.right = right === undefined ? null : right
  }
}

function inorderTraversal(root: TreeNode | null): number[] {
  const res: number[] = []
  recursTraversal(root, res)
  return res
}

function recursTraversal(node: TreeNode | null, arr: number[]) {
  if (node) {
    recursTraversal(node.left, arr)
    arr.push(node.val)
    recursTraversal(node.right, arr)
  }
}
```

后序遍历：

demo-project\14-大厂面试题Leetcode\12-二叉树后序遍历.ts

```typescript
// Definition for a binary tree node.
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val
    this.left = left === undefined ? null : left
    this.right = right === undefined ? null : right
  }
}

function postorderTraversal(root: TreeNode | null): number[] {
  const res: number[] = []
  recursTravaersel(root, res)
  return res
}

function recursTravaersel(node: TreeNode | null, arr: number[]) {
  if (node) {
    recursTravaersel(node.left, arr)
    recursTravaersel(node.right, arr)
    arr.push(node.val)
  }
}
```

层序遍历

demo-project\14-大厂面试题Leetcode\13-二叉树层序遍历.ts

```typescript
// Definition for a binary tree node.
class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val
    this.left = left === undefined ? null : left
    this.right = right === undefined ? null : right
  }
}

function levelOrder(root: TreeNode | null): number[][] {
  if (!root) return []

  const result: number[][] = []
  const queue: TreeNode[] = [root]

  while (queue.length > 0) {
    const levelSize = queue.length
    const currentLevel: number[] = []

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift()! // 移除队首节点，并获取其值
      currentLevel.push(node.val)

      if (node?.left) {
        queue.push(node.left)
      }
      if (node?.right) {
        queue.push(node.right)
      }
    }

    result.push(currentLevel)
  }

  return result
}
```

### 2.翻转二叉树

翻转二叉树（Max Howell去Google面试没有写出来的题目）

[Leetcode 原题](https://leetcode.cn/problems/invert-binary-tree/description/)

方案一：递归

demo-project\14-大厂面试题Leetcode\14-翻转二叉树.ts

```typescript
// Definition for a binary tree node.
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val
    this.left = left === undefined ? null : left
    this.right = right === undefined ? null : right
  }
}

function invertTree(root: TreeNode | null): TreeNode | null {
  if (!root) return null

  const left = invertTree(root.left)
  const right = invertTree(root.right)

  root.left = right
  root.right = left

  return root
}
```

方案二：循环 + 栈结构



---

二叉树的最大路径和

使用深度优先搜索

---

动态规划

不同路径

使用二维数组 + 动态规划

初始化第一排，第一列的值。

---

礼物的最大价值

动态规划 + 二维数组

---

最长递增子序列

动态规划

贪心 + 二分查找